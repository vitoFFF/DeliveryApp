-- Create a table for public user profiles
CREATE TABLE public.users (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  avatar_url TEXT,
  updated_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Set up Row Level Security (RLS)
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public profiles are viewable by everyone." ON public.users FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.users FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON public.users FOR UPDATE USING (auth.uid() = id);

-- This trigger automatically creates a profile entry when a new user signs up.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, full_name, avatar_url)
  VALUES (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Custom types for roles
CREATE TYPE public.app_role AS ENUM ('admin', 'user', 'driver');
CREATE TYPE public.app_permission AS ENUM ('venues.delete', 'products.delete', 'categories.delete');

-- Create a table for roles
CREATE TABLE public.roles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role app_role NOT NULL UNIQUE
);
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow public read access" ON public.roles FOR SELECT USING (true);

-- Seed the roles
INSERT INTO public.roles (role) VALUES ('admin'), ('user'), ('driver');

-- Create a table for user roles
CREATE TABLE public.user_roles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.users(id) ON DELETE CASCADE NOT NULL,
  role_id BIGINT REFERENCES public.roles(id) ON DELETE CASCADE NOT NULL,
  UNIQUE (user_id, role_id)
);
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual read access" ON public.user_roles FOR SELECT USING (auth.uid() = user_id);


-- Function to get the roles of the current user
CREATE OR REPLACE FUNCTION public.get_my_roles()
RETURNS SETOF app_role AS $$
BEGIN
  RETURN QUERY
  SELECT r.role
  FROM public.user_roles ur
  JOIN public.roles r ON ur.role_id = r.id
  WHERE ur.user_id = auth.uid();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Function to check if a user has a specific role
CREATE OR REPLACE FUNCTION public.is_user_in_role(p_user_id UUID, p_role app_role)
RETURNS BOOLEAN AS $$
DECLARE
  has_role BOOLEAN;
BEGIN
  SELECT EXISTS (
    SELECT 1
    FROM public.user_roles ur
    JOIN public.roles r ON ur.role_id = r.id
    WHERE ur.user_id = p_user_id AND r.role = p_role
  ) INTO has_role;
  RETURN has_role;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- Add role to user profile for easier access on the client
ALTER TABLE public.users ADD COLUMN role app_role NOT NULL DEFAULT 'user';

-- Trigger to update the role in public.users when user_roles changes
CREATE OR REPLACE FUNCTION public.update_user_role_from_join_table()
RETURNS TRIGGER AS $$
DECLARE
  new_role app_role;
BEGIN
  -- Find the role from the roles table
  SELECT r.role INTO new_role
  FROM public.roles r
  WHERE r.id = NEW.role_id;

  -- Update the users table
  UPDATE public.users
  SET role = new_role
  WHERE id = NEW.user_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_user_role_change
  AFTER INSERT OR UPDATE ON public.user_roles
  FOR EACH ROW EXECUTE PROCEDURE public.update_user_role_from_join_table();

-- Function to assign a role to a user
CREATE OR REPLACE FUNCTION public.assign_role_to_user(p_user_id UUID, p_role app_role)
RETURNS VOID AS $$
DECLARE
  v_role_id BIGINT;
BEGIN
  SELECT id INTO v_role_id FROM public.roles WHERE role = p_role;
  IF v_role_id IS NULL THEN
    RAISE EXCEPTION 'Role % not found', p_role;
  END IF;

  INSERT INTO public.user_roles (user_id, role_id)
  VALUES (p_user_id, v_role_id)
  ON CONFLICT (user_id, role_id) DO NOTHING;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
